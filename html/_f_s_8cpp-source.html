<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>COP4610 Project 3: lab/pr3/FS.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lab/pr3/FS.cpp</h1><a href="_f_s_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00008 <span class="preprocessor">#include "<a class="code" href="_f_s_8h.html">FS.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="_directory_8h.html">Directory.h</a>"</span>
00010 
00011 FS::FS()
00012 { }
00013 
00014 FS::~FS()
00015 { }
00016 
<a name="l00017"></a><a class="code" href="class_f_s.html#a2">00017</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a2">FS::open</a>(<a class="code" href="class_volume.html">Volume</a>&amp; volume, <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00018 {
00019   <span class="keywordtype">int</span> fd = 0;
00020 
00021   TODO(<span class="stringliteral">"Implement FS::open()"</span>);
00022 
00023   <span class="comment">// Check if file was already opened (has entry in open file table):</span>
00024   <span class="comment">// Check all open file entries for count &gt; 0.</span>
00025   <span class="comment">// If the volume, path, and file name match, then ++count and return fd.</span>
00026 
00027   <span class="comment">// Otherwise, set fd to a free entry in the open file table with count == 0</span>
00028   <span class="comment">// and set the open_file.name to the open() name argument.</span>
00029 
00030   <span class="comment">// If no entries are available then report error and return DISK_ERROR.</span>
00031 
00032   assert(open_file_table[fd].count == 0);
00033 
00034   <a class="code" href="class_open_file.html">OpenFile</a>&amp; open_file = open_file_table[fd];
00035 
00036   <span class="comment">// Create a Directory object for the volume's FAT and use Directory::chdir()</span>
00037   <span class="comment">// to move to the path location of the file.</span>
00038   <span class="comment">// The dir should now point to the directory of the file.</span>
00039   <span class="comment">// If the dir does not exist, then report and return DISK_ERROR.</span>
00040 
00041   <span class="comment">// Get the FCB of the file via the dir object.</span>
00042 
00043   <span class="comment">// If there is no FCB, then this is a new file so we create a new FCB with</span>
00044   <span class="comment">// size = 0, type = FILE_TYPE, created = time(NULL), and we allocate a new</span>
00045   <span class="comment">// start_block from the FAT of the volume.</span>
00046 
00047   <span class="comment">// Otherwise, if there is an FCB, then set the open_file.size and</span>
00048   <span class="comment">// open_file.start_block from the FCB attributes.</span>
00049 
00050   <span class="comment">// Set the other open_file attributes:</span>
00051   <span class="comment">// open_file.pos = 0;</span>
00052   <span class="comment">// open_file.current_block = open_file.start_block;</span>
00053   <span class="comment">// open_file.current_block_pos = 0;</span>
00054   <span class="comment">// open_file.updated = false;</span>
00055 
00056   <span class="comment">// Increment the open_file.count.</span>
00057 
00058   fd = <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00059 
00060   <span class="keywordflow">return</span> fd;
00061 }
00062 
<a name="l00063"></a><a class="code" href="class_f_s.html#a3">00063</a> <span class="keywordtype">void</span> <a class="code" href="class_f_s.html#a3">FS::close</a>(<span class="keywordtype">int</span> fd)
00064 {
00065   <a class="code" href="class_open_file.html">OpenFile</a>&amp; open_file = open_file_table[fd];
00066 
00067   assert(open_file.<a class="code" href="class_open_file.html#o0">count</a> &gt; 0);
00068 
00069   TODO(<span class="stringliteral">"Implement FS::close()"</span>);
00070 
00071   <span class="comment">// If the file was updated, update its FCB in the directory:</span>
00072   <span class="keywordflow">if</span> (open_file.<a class="code" href="class_open_file.html#o9">updated</a>)
00073   {
00074   <span class="comment">// Create a Directory object for the volume's FAT and use Directory::chdir()</span>
00075   <span class="comment">// to move to the path location of the file.</span>
00076   <span class="comment">// The dir should now point to the directory of the file.</span>
00077   <span class="comment">// If the dir does not exist, then report and return DISK_ERROR.</span>
00078 
00079   <span class="comment">// Get the FCB object of the file, update it with the open_file attributes</span>
00080   <span class="comment">// such as size, and set the FCB of the file</span>
00081 
00082   <span class="comment">// What to do if the FCB was not found? This could happen when the file is</span>
00083   <span class="comment">// deleted before closed. So rm() must check if the file is not open!</span>
00084   }
00085 
00086   <span class="comment">// Decrement the open_file.count</span>
00087 }
00088 
<a name="l00089"></a><a class="code" href="class_f_s.html#a4">00089</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a4">FS::read</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len)
00090 {
00091   <a class="code" href="class_open_file.html">OpenFile</a>&amp; open_file = open_file_table[fd];
00092 
00093   assert(open_file.<a class="code" href="class_open_file.html#o0">count</a> &gt; 0);
00094 
00095   TODO(<span class="stringliteral">"Implement FS::read()"</span>);
00096 
00097   <span class="keywordtype">char</span> blk[<a class="code" href="includes_8h.html#a2">MAX_BLOCK_SIZE</a>];
00098 
00099   <span class="comment">// We need to copy data of at most len bytes from disk to the buf argument.</span>
00100 
00101   <span class="comment">// To do so, use a loop to copy the data in chunks.</span>
00102   <span class="comment">// Within the loop, update the open_file.pos position in the file,</span>
00103   <span class="comment">// the open_file.current_block, and open_file.current_block_pos offset into</span>
00104   <span class="comment">// the current block being read.</span>
00105 
00106   <span class="comment">// You need to get the FAT of the volume of the open file and use find_next()</span>
00107   <span class="comment">// to find the blocks.</span>
00108 
00109   <span class="comment">// Return the number of bytes copied, or DISK_ERROR when an error occurred.</span>
00110 
00111   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00112 }
00113 
<a name="l00114"></a><a class="code" href="class_f_s.html#a5">00114</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a5">FS::write</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len)
00115 {
00116   <a class="code" href="class_open_file.html">OpenFile</a>&amp; open_file = open_file_table[fd];
00117 
00118   assert(open_file.<a class="code" href="class_open_file.html#o0">count</a> &gt; 0);
00119 
00120   open_file.<a class="code" href="class_open_file.html#o9">updated</a> = <span class="keyword">true</span>;
00121 
00122   TODO(<span class="stringliteral">"Implement FS::write()"</span>);
00123 
00124   <span class="keywordtype">char</span> blk[<a class="code" href="includes_8h.html#a2">MAX_BLOCK_SIZE</a>];
00125 
00126   <span class="comment">// We need to copy data from buf of length len to disk.</span>
00127 
00128   <span class="comment">// To do so, use a loop to copy the data in chunks.</span>
00129   <span class="comment">// Within the loop, update the open_file.size, open_file.pos,</span>
00130   <span class="comment">// the open_file.current_block, and open_file.current_block_pos offset into</span>
00131   <span class="comment">// the current block being written.</span>
00132 
00133   <span class="comment">// You need to get the FAT of the volume of the open file and use</span>
00134   <span class="comment">// alloc_next() to find or get new blocks.</span>
00135 
00136   <span class="comment">// Note that writing data inside blocks may require reading blocks first.</span>
00137 
00138   <span class="comment">// Return DISK_OK or DISK_ERROR.</span>
00139 
00140   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00141 }
00142 
<a name="l00143"></a><a class="code" href="class_f_s.html#a6">00143</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a6">FS::seek</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">int</span> pos)
00144 {
00145   <a class="code" href="class_open_file.html">OpenFile</a>&amp; open_file = open_file_table[fd];
00146 
00147   assert(open_file.<a class="code" href="class_open_file.html#o0">count</a> &gt; 0);
00148 
00149   TODO(<span class="stringliteral">"Implement FS::seek()"</span>);
00150 
00151   <span class="comment">// Change the open_file.pos, open_file.current_block, and</span>
00152   <span class="comment">// open_file.current_block_pos within the allowable range of the file</span>
00153   <span class="comment">// where the range is 0 to size-1.</span>
00154 
00155   <span class="comment">// Return DISK_OK or DISK_ERROR when an error occurred</span>
00156 
00157   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00158 }
00159 
<a name="l00160"></a><a class="code" href="class_f_s.html#a7">00160</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a7">FS::ls</a>(<a class="code" href="class_volume.html">Volume</a>&amp; volume, <span class="keyword">const</span> <span class="keywordtype">char</span> *path)
00161 {
00162   <a class="code" href="class_directory.html">Directory</a> dir(volume.<a class="code" href="class_volume.html#a3">get_fat</a>());
00163 
00164   dir.chdir(path);
00165 
00166   printf(<span class="stringliteral">"Volume %s:%s (%d blocks, %d free)\n"</span>, volume.<a class="code" href="class_volume.html#a2">get_name</a>(), path, volume.<a class="code" href="class_volume.html#a3">get_fat</a>().<a class="code" href="class_f_a_t.html#a6">num_blocks</a>(), volume.<a class="code" href="class_volume.html#a3">get_fat</a>().<a class="code" href="class_f_a_t.html#a7">num_free_blocks</a>());
00167 
00168   dir.list();
00169 
00170   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a0">DISK_OK</a>;
00171 }
00172 
<a name="l00173"></a><a class="code" href="class_f_s.html#a8">00173</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a8">FS::rm</a>(<a class="code" href="class_volume.html">Volume</a>&amp; volume, <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00174 {
00175   TODO(<span class="stringliteral">"Implement FS::rm()"</span>);
00176 
00177   <span class="comment">// Check if this is a regular file.</span>
00178 
00179   <span class="comment">// Check if the file is not open.</span>
00180 
00181   <span class="comment">// Create a Directory object for the volume's FAT and use Directory::chdir()</span>
00182   <span class="comment">// to move to the path location of the file.</span>
00183   <span class="comment">// The dir should now point to the directory of the file.</span>
00184   <span class="comment">// If the dir does not exist, then report and return DISK_ERROR.</span>
00185 
00186   <span class="comment">// Use Directory::erase() to remove the file.</span>
00187 
00188   <span class="comment">// Return DISK_OK or DISK_ERROR.</span>
00189 
00190   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00191 }
00192 
<a name="l00193"></a><a class="code" href="class_f_s.html#a9">00193</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a9">FS::mkdir</a>(<a class="code" href="class_volume.html">Volume</a>&amp; volume, <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00194 {
00195   <a class="code" href="class_directory.html">Directory</a> dir(volume.<a class="code" href="class_volume.html#a3">get_fat</a>());
00196 
00197   dir.chdir(path);
00198 
00199   <a class="code" href="class_file_name.html">FileName</a> dir_name(name);
00200 
00201   <span class="keywordflow">return</span> dir.mkdir(dir_name);
00202 }
00203 
<a name="l00204"></a><a class="code" href="class_f_s.html#a10">00204</a> <span class="keywordtype">int</span> <a class="code" href="class_f_s.html#a10">FS::rmdir</a>(<a class="code" href="class_volume.html">Volume</a>&amp; volume, <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
00205 {
00206   <a class="code" href="class_directory.html">Directory</a> dir(volume.<a class="code" href="class_volume.html#a3">get_fat</a>());
00207 
00208   dir.chdir(path);
00209 
00210   <a class="code" href="class_file_name.html">FileName</a> dir_name(name);
00211 
00212   TODO(<span class="stringliteral">"Complete FS::rmdir()"</span>);
00213 
00214   <span class="comment">// Check if this is a directory.</span>
00215 
00216   <span class="comment">// Check if the directory is empty.</span>
00217 
00218   <span class="keywordflow">return</span> dir.erase(dir_name);
00219 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Fri Mar 24 14:26:14 2006 for COP4610 Project 3 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
