<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>COP4610 Project 3: lab/pr3/FAT.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lab/pr3/FAT.cpp</h1><a href="_f_a_t_8cpp.html">Go to the documentation of this file.</a><pre class="fragment"><div>00001 
00008 <span class="preprocessor">#include "<a class="code" href="_f_a_t_8h.html">FAT.h</a>"</span>
00009 
00010 FAT::FAT(<a class="code" href="class_disk.html">Disk</a>&amp; disk) : disk(disk)
00011 {
00012   <span class="comment">// Allocate the FAT entries</span>
00013 
00014   entry = <span class="keyword">new</span> <span class="keywordtype">int</span>[disk.<a class="code" href="class_disk.html#a0">num_blocks</a>()];
00015 
00016   <span class="comment">// Populate the FAT from Disk</span>
00017 
00018   retrieve();
00019 }
00020 
00021 FAT::~FAT()
00022 {
00023   <span class="keywordflow">if</span> (entry)
00024   {
00025     flush();
00026     <span class="keyword">delete</span> entry;
00027   }
00028 }
00029 
<a name="l00030"></a><a class="code" href="class_f_a_t.html#a2">00030</a> <span class="keywordtype">int</span> <a class="code" href="class_f_a_t.html#a2">FAT::alloc</a>()
00031 {
00032   <span class="comment">// Search the FAT for a free entry</span>
00033 
00034   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_num = 0; block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>(); ++block_num)
00035   {
00036     <span class="keywordflow">if</span> (entry[block_num] == <a class="code" href="_f_a_t_8h.html#a0">FAT_FREE</a>)
00037     {
00038       entry[block_num] = <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>;
00039 
00040       <span class="keywordflow">return</span> block_num;
00041     }
00042   }
00043 
00044   <span class="keywordflow">return</span> <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>;
00045 }
00046 
<a name="l00047"></a><a class="code" href="class_f_a_t.html#a3">00047</a> <span class="keywordtype">int</span> <a class="code" href="class_f_a_t.html#a3">FAT::alloc_next</a>(<span class="keywordtype">int</span> block_num)
00048 {
00049   assert(block_num &gt;= 0 &amp;&amp; block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>());
00050 
00051   <span class="comment">// Check if the entry is FAT_END, if not then return the entry's value</span>
00052 
00053   <span class="keywordflow">if</span> (entry[block_num] != <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>)
00054     <span class="keywordflow">return</span> entry[block_num];
00055 
00056   <span class="comment">// Allocate a new block and link it to the entry for block_num.</span>
00057 
00058   <span class="keywordflow">return</span> entry[block_num] = <a class="code" href="class_f_a_t.html#a2">alloc</a>();
00059 }
00060 
<a name="l00061"></a><a class="code" href="class_f_a_t.html#a4">00061</a> <span class="keywordtype">int</span> <a class="code" href="class_f_a_t.html#a4">FAT::find_next</a>(<span class="keywordtype">int</span> block_num)
00062 {
00063   assert(block_num &gt;= 0 &amp;&amp; block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>());
00064 
00065   <span class="comment">// Check if the entry is FAT_END, if not then return the entry's value</span>
00066 
00067   <span class="keywordflow">if</span> (entry[block_num] != <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>)
00068     <span class="keywordflow">return</span> entry[block_num];
00069 
00070   <span class="keywordflow">return</span> <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>;
00071 } 
00072 
<a name="l00073"></a><a class="code" href="class_f_a_t.html#a5">00073</a> <span class="keywordtype">void</span> <a class="code" href="class_f_a_t.html#a5">FAT::clear</a>(<span class="keywordtype">int</span> block_num)
00074 {
00075   assert(block_num &gt;= 0 &amp;&amp; block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>());
00076 
00077   <span class="comment">// Clear the chain of blocks starting at block_num</span>
00078 
00079   <span class="keywordflow">while</span> (block_num != <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>)
00080   {
00081     <span class="keywordtype">int</span> next_block = entry[block_num];
00082     entry[block_num] = <a class="code" href="_f_a_t_8h.html#a0">FAT_FREE</a>;
00083     block_num = next_block;
00084   }
00085 }
00086 
<a name="l00087"></a><a class="code" href="class_f_a_t.html#a6">00087</a> <span class="keywordtype">int</span> <a class="code" href="class_f_a_t.html#a6">FAT::num_blocks</a>()<span class="keyword"> const</span>
00088 <span class="keyword"></span>{
00089   <span class="keywordflow">return</span> disk.<a class="code" href="class_disk.html#a0">num_blocks</a>();
00090 }
00091 
<a name="l00092"></a><a class="code" href="class_f_a_t.html#a7">00092</a> <span class="keywordtype">int</span> <a class="code" href="class_f_a_t.html#a7">FAT::num_free_blocks</a>()<span class="keyword"> const</span>
00093 <span class="keyword"></span>{
00094   <span class="keywordtype">int</span> count = 0;
00095 
00096   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_num = 0; block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>(); ++block_num)
00097     <span class="keywordflow">if</span> (entry[block_num] == <a class="code" href="_f_a_t_8h.html#a0">FAT_FREE</a>)
00098       ++count;
00099 
00100   <span class="keywordflow">return</span> count;
00101 }
00102 
<a name="l00103"></a><a class="code" href="class_f_a_t.html#a8">00103</a> <span class="keywordtype">int</span> <a class="code" href="class_f_a_t.html#a8">FAT::fat_num_blocks</a>()<span class="keyword"> const</span>
00104 <span class="keyword"></span>{
00105   <span class="comment">// How many entries fit into a disk block?</span>
00106 
00107   <span class="keywordtype">int</span> entries_per_block = disk.<a class="code" href="class_disk.html#a1">block_size</a>() / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
00108 
00109   <span class="comment">// How many blocks are reserved for the FAT?</span>
00110 
00111   <span class="keywordflow">return</span> (disk.<a class="code" href="class_disk.html#a0">num_blocks</a>() + entries_per_block - 1) / entries_per_block;
00112 }
00113 
<a name="l00114"></a><a class="code" href="class_f_a_t.html#a9">00114</a> <a class="code" href="class_disk.html">Disk</a>&amp; <a class="code" href="class_f_a_t.html#a9">FAT::get_disk</a>()
00115 {
00116   <span class="keywordflow">return</span> disk;
00117 }
00118 
00119 <span class="keywordtype">void</span> FAT::init()
00120 {
00121   <span class="keywordtype">int</span> block_num;
00122 
00123   <span class="comment">// Reserve the first fat_num_blocks() for the FAT</span>
00124 
00125   <span class="keywordflow">for</span> (block_num = 0; block_num &lt; <a class="code" href="class_f_a_t.html#a8">fat_num_blocks</a>(); ++block_num)
00126     entry[block_num] = <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>;
00127 
00128   <span class="comment">// Set the remaining entries to FAT_FREE</span>
00129 
00130   <span class="keywordflow">for</span> (; block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>(); ++block_num)
00131     entry[block_num] = <a class="code" href="_f_a_t_8h.html#a0">FAT_FREE</a>;
00132 }
00133 
00134 <span class="keywordtype">int</span> FAT::retrieve()
00135 {
00136   message(<span class="stringliteral">"FAT retrieve\n"</span>);
00137 
00138   <span class="comment">// How many entries fit into a disk block?</span>
00139 
00140   <span class="keywordtype">int</span> entries_per_block = disk.<a class="code" href="class_disk.html#a1">block_size</a>() / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
00141 
00142   <span class="comment">// Get the FAT from Disk</span>
00143 
00144   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_num = 0; block_num &lt; <a class="code" href="class_f_a_t.html#a8">fat_num_blocks</a>(); ++block_num)
00145   {
00146     <span class="keywordtype">char</span> buf[<a class="code" href="includes_8h.html#a2">MAX_BLOCK_SIZE</a>];
00147 
00148     <span class="keywordflow">if</span> (disk.<a class="code" href="class_disk.html#a3">read</a>(block_num, buf) == <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>)
00149       <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00150     
00151     <span class="keywordtype">int</span> index = entries_per_block * block_num;
00152     <span class="keywordtype">int</span> entries;
00153     
00154     <span class="keywordflow">if</span> (index + entries_per_block &gt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>())
00155       entries = disk.<a class="code" href="class_disk.html#a0">num_blocks</a>() - index;
00156     <span class="keywordflow">else</span>
00157       entries = entries_per_block;
00158 
00159     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos = 0; pos &lt; entries; ++pos)
00160       entry[index + pos] = <a class="code" href="_util_8cpp.html#a1">ston</a>(buf + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*pos);
00161   }
00162 
00163   <span class="comment">// If the first entry is not FAT_END, the FAT on disk is invalid and we assume the disk was formatted.</span>
00164 
00165   <span class="keywordflow">if</span> (entry[0] != <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>)
00166     init();
00167 
00168   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a0">DISK_OK</a>;
00169 }
00170 
00171 <span class="keywordtype">int</span> FAT::flush()
00172 {
00173   message(<span class="stringliteral">"FAT flush\n"</span>);
00174 
00175   <span class="comment">// How many entries fit into a disk block?</span>
00176 
00177   <span class="keywordtype">int</span> entries_per_block = disk.<a class="code" href="class_disk.html#a1">block_size</a>() / <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
00178 
00179   <span class="comment">// Save the FAT to disk</span>
00180 
00181   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_num = 0; block_num &lt; <a class="code" href="class_f_a_t.html#a8">fat_num_blocks</a>(); ++block_num)
00182   {
00183     <span class="keywordtype">int</span> index = entries_per_block * block_num;
00184     <span class="keywordtype">int</span> entries;
00185     
00186     <span class="keywordflow">if</span> (index + entries_per_block &gt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>())
00187       entries = disk.<a class="code" href="class_disk.html#a0">num_blocks</a>() - index;
00188     <span class="keywordflow">else</span>
00189       entries = entries_per_block;
00190 
00191     <span class="keywordtype">char</span> buf[<a class="code" href="includes_8h.html#a2">MAX_BLOCK_SIZE</a>];
00192 
00193     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos = 0; pos &lt; entries; ++pos)
00194       <a class="code" href="_util_8cpp.html#a0">ntos</a>(buf + <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)*pos, entry[index + pos]);
00195 
00196     <span class="keywordflow">if</span> (disk.<a class="code" href="class_disk.html#a4">write</a>(block_num, buf) == <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>)
00197       <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a1">DISK_ERROR</a>;
00198   }
00199 
00200   <span class="keywordflow">return</span> <a class="code" href="_disk_8h.html#a0">DISK_OK</a>;
00201 }
00202 
<a name="l00203"></a><a class="code" href="class_f_a_t.html#a10">00203</a> <span class="keywordtype">void</span> <a class="code" href="class_f_a_t.html#a10">FAT::list</a>()
00204 {
00205   message1(<span class="stringliteral">"FAT (first %d blocks contain the FAT):\n"</span>, <a class="code" href="class_f_a_t.html#a8">fat_num_blocks</a>());
00206 
00207   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_num = <a class="code" href="class_f_a_t.html#a8">fat_num_blocks</a>(); block_num &lt; disk.<a class="code" href="class_disk.html#a0">num_blocks</a>(); ++block_num)
00208   {
00209     <span class="keywordflow">if</span> (entry[block_num] != <a class="code" href="_f_a_t_8h.html#a0">FAT_FREE</a>)
00210     {
00211       <span class="keywordtype">bool</span> show = <span class="keyword">true</span>;
00212 
00213       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_check = 0; block_check &lt; block_num; ++block_check)
00214       {
00215         <span class="keywordflow">if</span> (<a class="code" href="class_f_a_t.html#a4">find_next</a>(block_check) == block_num)
00216         {
00217           show = <span class="keyword">false</span>;
00218           <span class="keywordflow">break</span>;
00219         }
00220       }
00221       <span class="keywordflow">if</span> (show)
00222       {
00223         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> block_chain = block_num; block_chain != <a class="code" href="_f_a_t_8h.html#a1">FAT_END</a>; block_chain = <a class="code" href="class_f_a_t.html#a4">find_next</a>(block_chain))
00224           message1(<span class="stringliteral">"%d -&gt; "</span>, block_chain);
00225 
00226         message(<span class="stringliteral">"end\n"</span>);
00227       }
00228     }
00229   }
00230 }
</div></pre><hr size="1"><address style="align: right;"><small>Generated on Fri Mar 24 14:26:14 2006 for COP4610 Project 3 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.8 </small></address>
</body>
</html>
